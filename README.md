# Тестовое задание для ОЭЗ «АЛАБУГА»



## Задачи

<details>
  <summary>Задача 1 (нажмите, чтобы раскрыть описание)</summary>

Сейчас активно развивается новая история, основателем которой является Профессор А.С. Багиров. Он выяснил, что на протяжении многих лет на земле вместе с людьми существовали ящеры. Строительство пирамид, захват Байкала и еще много разных событий произошли благодаря ящерам.
Учёные ещё не выяснили, сколько времени ящеры существовали на земле. Они находят разные данные в виде даты начала и даты окончания, и чтобы проверить их на корректность, необходимо посчитать, сколько дней ящеры существовали для двух конкретных дат. Календарь ящеров очень похож на григорианский, лишь с тем исключением, что там нет високосных годов.
Вам даны дата начала и дата окончания существования ящеров, нужно найти количество полных дней и секунд в неполном дне, чтобы учёные смогли оценить, насколько даты корректны.

### Формат ввода

В первой строке содержатся 6 целых чисел _year1, month1, day1, hour1, min1, sec1_
(`1≤year1≤9999, 1≤month1≤12, 1≤day1≤31, 0≤hour1≤23, 0≤min1≤59, 0≤sec1≤59`)— дата начала существования ящеров.
Во второй строке содержатся 6 целых чисел _year2, month2, day2, hour2, min2, sec2_ (`1≤year2≤9999, 1≤month2≤12, 1≤day2≤31, 0≤hour2≤23, 0≤min2≤59, 0≤sec2≤59`)— дата окончания существования ящеров.
Гарантируется, что дата начала меньше, чем дата конца.

### Формат вывода
В первой и единственной строке выведите 2 числа: количество дней, сколько существовали ящеры, а также количество секунд в неполном дне.

**Пример 1**

**Ввод**

```
980 2 12 10 30 1
980 3 1 10 31 37
```

**Вывод**

`17 96`

**Пример 2**

**Ввод**

```
1001 5 20 14 15 16
9009 9 11 12 21 11
```
**Вывод**

`2923033 79555`

**Примечания**

Напоминаем:
В календаре древних ящеров:
* 	Нет високосных годов.
* 	В одном году 365 дней.
* 	Год делится на 12 месяцев, количество дней в каждом месяце: `[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]`.
* 	В одном дне 24 часа (от 0 до 23).
* 	В одном часу 60 минут (от 0 до 59).
* 	В одной минуте 60 секунд (от 0 до 59).

Первый тестовый пример.

* 	Года начала и конца совпадают;
* 	Между 12 февраля и 1 марта прошло 17 полных дней;
* 	Начало было в 10:30:01, а конец в 10:31:37 — таким образом дополнительно прошла 1 минута и 36 секунд, то есть 96 секунд.

Второй тестовый пример.

* 	Прошло 8008 полных лет;
* 	В каждом году 365 дней, суммарно получается 2922920 дней.
* 	От 20 дня 5 месяца до 20 дня 8 месяца прошли еще 31 + 30 + 31 день - суммарно 92 дня.
* 	От 20 дня 8 месяца до 10 дня 9 месяца прошло еще (31 - 20) + 10 = 21 полный день.
* 	Всего полных дней 2922920 + 92 + 21 = 2923033.
* 	От 10 дня 9 месяца 14:15:16 до 11 дня 9 месяца 12:21:11 прошло 79555 секунд.

</details>

  [Решение задачи 1](https://github.com/dazdik/alabuga_test_tasks/blob/main/calendar_lizardmen.py)


<details>
  <summary>Задача 2 (нажмите, чтобы раскрыть описание)</summary>

  Два друга `A` и `B` постоянно играют в коллекционную карточную игру (`ККИ`), поэтому у каждого игрока скопилась довольно большая коллекция карт. Каждая карта в данной игре задаётся целым числом (одинаковые карты — одинаковыми числами, разные карты — разными). Таким образом коллекцию можно представить как неупорядоченный набор целых чисел (с возможными повторениями).

После каждого изменения коллекций друзья вычисляют показатель разнообразия следующим образом:
- `A` и `B` выкладывают на стол все карты из своей коллекции в два раздельных ряда;
- Далее друзья итеративно делают следующее:
  1. Если среди лежащих на столе карт игрока `A` есть такая же карта, как и среди лежащих карт игрока `B` — каждый игрок убирает данную карту со стола;
  2. Если таковых совпадений нет — процесс заканчивается.
- Разнообразием коллекций друзья называют суммарное количество оставшихся карт на столе.

**Обратите внимание:** друзья убирают карты только со стола, карты не удаляются из коллекций при вычислении разнообразия.

### Формат ввода
В первой строке через пробел заданы числа `N, M, Q` — количество карт в коллекциях игрока A и B и количество изменений соответственно. Далее следуют строки с описанием карт каждого игрока и изменений в коллекциях.

### Формат вывода
Необходимо вывести через пробел `Q` целых чисел — разнообразие коллекций игроков A и B после каждого изменения.

**Примеры ввода и вывода:**

**Пример 1**

**Ввод:**

```
2 5 10
1 2
1 2 3 4 5
1 A 3
1 A 4
1 A 5
1 A 6
1 A 7
-1 A 1
1 B 7
-1 A 6
-1 B 1
1 A 7
```
**Вывод:**

`2 1 0 1 2 3 2 1 0 1`

**Пример 2**

**Ввод:**

```
3 3 5
1000 2000 1001
1001 2001 1000
1 A 100000
-1 B 2001
1 B 2000
1 B 100001
1 A 1
```
**Вывод:**
  
`3 2 1 2 3 `

**Пример 3**

**Ввод:**

```
3 3 20
1 6 7
2 4 5
1 A 2
1 B 1
1 B 8
1 B 5
1 A 3
1 A 2
1 B 10
1 A 9
1 A 8
1 B 7
-1 A 1
-1 B 5
-1 B 5
-1 B 4
-1 A 6
-1 A 8
-1 A 2
-1 B 8
-1 B 10
-1 A 2
```
**Вывод:**
`5 4 5 6 7 8 9 10 9 8 9 8 7 6 5 6 5 4 3 4 `

**Примечания:**

_Первый тестовый пример:_

Изначально у игроков коллекции `A=[1,2]`, `B=[1,2,3,4,5]`. Рассмотрим изменения коллекций и соответствующие им разнообразия:
1. A=[1,2,3], B=[1,2,3,4,5] — со стола убирают карты [1,2,3], на столе остались [4,5] игрока B.
2. A=[1,2,3,4], B=[1,2,3,4,5] — со стола убирают карты [1,2,3,4], осталась только [5] игрока B.
3. A=[1,2,3,4,5], B=[1,2,3,4,5] — со стола убирают карты [1,2,3,4,5], на столе не осталось карт.
4. A=[1,2,3,4,5,6], B=[1,2,3,4,5] — со стола убирают карты [1,2,3,4,5], осталась только [6] игрока A.
5. A=[1,2,3,4,5,6,7], B=[1,2,3,4,5] — со стола убирают карты [1,2,3,4,5], остались только [6,7] игрока A.
6. A=[2,3,4,5,6,7], B=[1,2,3,4,5] — со стола убирают карты [2,3,4,5], остались только [6,7] игрока A и [1] игрока B.
7. A=[2,3,4,5,6,7], B=[1,2,3,4,5,7] — со стола убирают карты [2,3,4,5,7], остались только [6] игрока A и [1] игрока B.
8. A=[2,3,4,5,7], B=[1,2,3,4,5,7] — со стола убирают карты [2,3,4,5,7], осталась только [1] игрока B.
9. A=[2,3,4,5,7], B=[2,3,4,5,7] — со стола убирают карты [2,3,4,5,7], на столе не осталось карт.
10. A=[2,3,4,5,7,7], B=[2,3,4,5,7] — со стола убирают карты [2,3,4,5,7], на столе осталась только [7] игрока A.

_Второй тестовый пример:_

Изначально у игроков коллекции `A=[1000,1001,2000]`,` B=[1000,1001,2001]`. Рассмотрим изменения коллекций и соответствующие им разнообразия:
1. A=[1000,1001,2000,100000], B=[1000,1001,2001] — со стола убирают карты [1000,1001], остались только [2000,100000] игрока A и [2001] игрока B.
2. A=[1000,1001,2000,100000], B=[1000,1001] — со стола убирают карты [1000,1001], остались только [2000,100000] игрока A.
3. A=[1000,1001,2000,100000], B=[1000,1001,2000] — со стола убирают карт
4. A=[1000,1001,2000,100000], B=[1000,1001,2000,100001] — со стола убирают карты [1000,1001,2000], остались только [100000] игрока A и [100001] игрока B.
5. A=[1,1000,1001,2000,100000], B=[1000,1001,2000,100001] — со стола убирают карты [1000,1001,2000], остались только [1,100000] игрока A и [100001] игрока B.


</details>

[Решение задачи 2](https://github.com/dazdik/alabuga_test_tasks/blob/main/variety_of_collections.py)


<details>
  <summary>Задача 3 (нажмите, чтобы раскрыть описание)</summary>

  Петя пришел на стажировку, и первая его задача была познакомиться с SQL. У Пети есть табличка, состоящая из N строк и M столбцов, значениями которой являются целые числа. Каждой колонке соответствует уникальное имя — строка из латинских символов.

Пете задан запрос из Q ограничений вида: `ColumnNamek qk valk`, где `qk` может принимать два значения:
1. `>` — учитывать только те строки, где значения в `ColumnNamek` строго больше `valk`;
2. `<` — учитывать только те строки, где значения в `ColumnNamek` строго меньше `valk`.

Задача Пети заключается в том, чтобы посчитать сумму во всех строках, которые удовлетворяют всем ограничениям. Юный стажер уже написал скрипт и вычислил ответ. Но Петя волнуется, что где-то ошибся, поэтому просит вас перепроверить его вычисления.

### Формат ввода

На первой строке вводятся 3 числа `N`, `M`, `Q` (`1≤N×M≤3⋅10^5`, `1≤Q≤10^5`) — количество строк, столбцов в таблице и количество ограничений в запросе. В следующей строке вводятся через пробел `M` слов, состоящих из латинских маленьких букв — название соответствующей колонки, каждая строка по длине не превосходит `L` (`1≤L≤10`). Далее вводятся `N` строк, в каждой через пробел `M` целых чисел `aij` (`−10^9≤aij≤10^9`) — элементы `i`-ой строки. Потом вводятся `Q` строк — ограничения к запросу. Каждая строка имеет вид `ColumnNamek qk valk` (`qk∈(<,>)`; `−10^9≤valk≤10^9`) — `k`-ое ограничение в формате, описанном в условии задачи. Гарантируется, что `ColumnNamek` соответствует имени одной из колонок таблицы.

### Формат вывода

Выведите единственное значение `S` — сумму всех чисел в строках, удовлетворяющих всем заданным ограничениям. Если никакая строка не удовлетворяет всем ограничениям — выведите в ответ 0.

### Пример

**Ввод:**

```
2 2 3
a b
1 1
2 2
a < 3
b > 1
b < 3
```
**Вывод:**

`4`

### Примечания

Первый тестовый пример:

В табличке есть две строки:
1. (a=1,b=1);
2. (a=2,b=2);

Рассмотрим ограничения из запроса:
1. первому ограничению "a<3" соответствуют обе строки: (1<3) и (2<3);
2. второму ограничению "b>1" соответствует только вторая строка: неверно, что (1>1), но верно (2>1);
3. третьему ограничению "b<3" соответствуют обе строки: (1<3

</details>

[Решение задачи 3](https://github.com/dazdik/alabuga_test_tasks/blob/main/petya_script.py)


<details>
  <summary>Задача 4 (нажмите, чтобы раскрыть описание)</summary>

  Межпланетная организация имеет иерархическую древовидную структуру:
- Корнем иерархии является генеральный директор;
- У каждого сотрудника 0 или более непосредственных подчиненных;
- Каждый сотрудник, кроме генерального директора, является непосредственным подчиненным ровно одному сотруднику.

Каждый сотрудник, кроме генерального директора, говорит либо на языке `A`, либо на языке `B`. Директор говорит на двух языках для управления всей организацией. Структура всей организации хранится в текстовом документе, где каждый сотрудник представлен уникальным идентификатором - целым числом от `0` до `N` включительно, где `0` - идентификатор генерального директора.

### Формат ввода

- Первая строка содержит целое число `N` (`1≤N≤10^6`) — количество сотрудников (без генерального директора).
- Во второй строке через пробел задано `N` символов `Li` (`Li`∈{`A,B`}) — язык i-го сотрудника.
- В третьей строке через пробел задано `2`⋅(`N+1`) целых чисел `Pj` (`0`≤`Pj`≤`N`) — иерархия организации.

### Формат вывода

Выведите `N` целых чисел через пробел — языковой барьер каждого сотрудника от `1` до `N` включительно.

### Примеры

**Пример 1:**

**Ввод:**

```
5
A B B A B
0 1 1 2 3 4 4 5 5 3 2 0
```

**Вывод:**

`0 0 0 2 0`

**Пример 2:**

**Ввод:**

```
4
A B A A
0 1 2 3 3 4 4 2 1 0
```
**Вывод:**

`0 1 1 1`


### Примечания

Первый тестовый пример соответствует организационной структуре, где все сотрудники, кроме сотрудника 4, имеют нулевой языковой барьер. Сотрудник 4 имеет языковой барьер равный 2, так как ближайший начальник, говорящий на том же языке — генеральный директор 0, а между директором и данным сотрудником ровно два начальника (3 и 2).

Второй тестовый пример соответствует примеру, описанному в условии задачи.
</details>

  [Решение задачи 4](https://github.com/dazdik/alabuga_test_tasks/blob/main/language_barrier.py)


<details>
  <summary>Задача 5 (нажмите, чтобы раскрыть описание)</summary>

Определим близость двух целочисленных массивов как длину их наибольшего совпадающего префикса. Например, близость массивов [1, 2, 1, 3] и [1, 2, 3, 2] равна 2, так как их общий префикс [1, 2] совпадает, в то время как близость массивов [1, 2, 3] и [3, 2, 1] равна 0.

Задача состоит в том, чтобы для данного набора `n` целочисленных массивов `a1, a2, …, an` вычислить сумму близостей массивов `ai` и `aj` для каждой пары `1≤i<j≤n`.

### Формат ввода

- Первая строка содержит одно целое число `n` (`1≤n≤3⋅10^5`) — количество массивов.
- Каждый массив задаётся двумя строками:
  - Первая строка описания массива содержит единственное целое число `ki` (`1≤k≤3⋅10^5`) — размер `i`-го массива.
  - Вторая строка описания содержит `ki` целых чисел `aij` (`1≤aij≤10^9`) — элементы `i`-го массива.

Гарантируется, что сумма размеров всех массивов не превышает `3⋅10^5`.

### Формат вывода

Выведите единственное целое число — суммарную попарную близость массивов.

### Примеры

**Пример 1:**

**Ввод:**

```
3
2
1 2
2
1 3
3
1 2 3
```

**Вывод:**

`4`

**Пример 2:**

**Ввод:**

```
3
1
5
2
1 2
3
5 1 2
```
**Вывод:**

`1`


### Примечания

Префиксом длины `p` массива `a` назовем `p` первых элементов массива `a`. Например, у массива `[1, 2, 1]` есть 4 различных префикса: длины 0 — `[]` (пустой), длины 1 — `[1]`, длины 2 — `[1, 2]`, длины 3 — `[1, 2, 1]`.

В первом тестовом примере близость массивов `[1,2]` и `[1,3]` равна 1 (общий префикс `[1]`), `[1,2]` и `[1,2,3]` равна 2 (общий префикс `[1,2]`), `[1,3]` и `[1,2,3]` равна 1 (общий префикс `[1]`). Суммарно получается `1+2+1=4`.

Во втором тестовом примере близость массивов `[5]` и `[1,2]` равна 0 (общий префикс `[]`), `[5]` и `[5,1,2]` равна 1 (общий префикс `[5]`), `[1,2]` и `[5,1,2]` равна 0 (общий префикс `[]`). Суммарно получается `0+1+0=1`.


</details>

  [Решение задачи 5](https://github.com/dazdik/alabuga_test_tasks/blob/main/proximity_arrays.py)



